{
  "name": "weak-map",
  "version": "1.0.3",
  "description": "A WeakMap shim for Node.js and browsers",
  "main": "weak-map.js",
  "scripts": {
    "test": "./verify",
    "bench": "matcha bench.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/drses/weak-map.git"
  },
  "keywords": [
    "weakmap",
    "weak-map",
    "weak",
    "map",
    "collections",
    "es6"
  ],
  "author": {
    "name": "Mark Miller",
    "email": "erights@gmail.com"
  },
  "maintainer": "Kris Kowal <kris@cixar.com>",
  "license": "Apache 2.0",
  "bugs": {
    "url": "https://github.com/drses/weak-map/issues"
  },
  "devDependencies": {
    "matcha": "~0.4.1"
  },
  "readme": "\n`WeakMap` is a collection slated to be introduced to JavaScript with\nEcmaScript 6.  It provides a mapping from objects to values, but allows\nany entry to be garbage collected if the key is provably lost.\n\nIn order for it to be possible that a key is provably lost, weak maps do\nnot provide a way to access the key list.\n\nThis is a Node Packaged Module (NPM) that provides a shim and patcher\nfor missing or broken WeakMap implementations suitable for use in\nNode.js and browsers that provide the EcmaScript 5 property description\ninterfaces provided that it hosted by a CommonJS loader or bundler like\n[Browserify][], [Montage][], [Mr][], or [Mop][].\n\n[Browserify]: https://github.com/substack/node-browserify\n[Montage]: https://github.com/montagejs/mr\n[Mr]: https://github.com/montagejs/mr\n[Mop]: https://github.com/montagejs/mop\n\n```\nnpm install weak-map --save\n```\n\n```javascript\nvar WeakMap = require(\"weak-map\");\nvar map = new WeakMap();\nvar key = {};\nmap.set(key, \"Hello, World!\");\nmap.get(key) === \"Hello, World!\";\nkey = null;\n// \"Hello, World!\" may be collected\n```\n\nSee [MDN][] for the API details.\n\n[MDN]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\n\nAt time of writing, prototype implementations of `WeakMap` exist in V8\nand Spidermonkey.  The prototype is available in Node.js v0.10 with the\n`--harmony_collections` V8 option.  In v0.8, it was available with\n`--harmony_weakmaps`.  The purpose of this package is to enable\ndependees to use weak maps regardless of whether they are implemented by\nthe underlying engine, albeit in a way that leaks memory in some\nnon-obvious cases.\n\nThe canonical implementation of `WeakMap` exists in the Google Caja\nSubversion repository at http://google-caja.googlecode.com/svn/trunk.\nIt was written by Mark S. Miller.  It is released by Google with the\nApache 2.0 license.  This package is maintained by Kris Kowal.\n\nIn a nutshell, the WeakMap shim emulates a WeakMap by adding a hidden\nproperty to the key that associates the weak map with the retained\nobject.  Thus, in many cases, if the key is garbage collected, the value\nmay be garbage collected.  I will leave [Mark Miller][Proposal] to\nevince the details.  The shim depends on EcmaScript 5’s API’s to cover\nits tracks.\n\n[Proposal]: http://wiki.ecmascript.org/doku.php?id=harmony:weak_maps\n\nAs stated by Mark Miller in the code:\n\n> As with true WeakMaps, in this emulation, a key does not retain maps indexed by\n> that key and (crucially) a map does not retain the keys it indexes. A map by\n> itself also does not retain the values associated with that map.\n>\n> However, the values associated with a key in some map are retained so long as\n> that key is retained and those associations are not overridden. For example,\n> when used to support membranes, all values exported from a given membrane will\n> live for the lifetime they would have had in the absence of an interposed\n> membrane. Even when the membrane is revoked, all objects that would have been\n> reachable in the absence of revocation will still be reachable, as far as the\n> GC can tell, even though they will no longer be relevant to ongoing\n> computation.\n>\n> The API implemented here is approximately the API as implemented\n> in FF6.0a1 and agreed to by MarkM, Andreas Gal, and Dave Herman,\n> rather than the offially approved proposal page.\n>\n> The first difference between the emulation here and that in FF6.0a1 is the\n> presence of non enumerable `get___`, `has___`, `set___`, and `delete___`}\n> methods on WeakMap instances to represent what would be the hidden internal\n> properties of a primitive implementation. Whereas the FF6.0a1 WeakMap.prototype\n> methods require their `this` to be a genuine WeakMap instance (i.e., an object\n> of `[[Class]]` \"WeakMap}), since there is nothing unforgeable about the\n> pseudo-internal method names used here, nothing prevents these emulated\n> prototype methods from being applied to non-WeakMaps with pseudo-internal\n> methods of the same names.\n>\n> Another difference is that our emulated `WeakMap.prototype` is not itself a\n> WeakMap. A problem with the current FF6.0a1 API is that WeakMap.prototype is\n> itself a WeakMap providing ambient mutability and an ambient communications\n> channel. Thus, if a WeakMap is already present and has this problem,\n> repairES5.js wraps it in a safe wrappper in order to prevent access to this\n> channel. (See PATCH_MUTABLE_FROZEN_WEAKMAP_PROTO in repairES5.js).\n\nThis refers to `repairES5.js` as provided by Google Caja.\n\n",
  "readmeFilename": "README.md",
  "_id": "weak-map@1.0.3",
  "dist": {
    "shasum": "b75390a7602d2e09b00305d66b6cb366829ab6dc"
  },
  "_from": "weak-map@~1.0.3",
  "_resolved": "https://registry.npmjs.org/weak-map/-/weak-map-1.0.3.tgz"
}
